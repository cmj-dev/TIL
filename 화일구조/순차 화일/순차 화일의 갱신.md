# **순차 화일의 생성**
트랙잭션 화일을 이용해서 갱신(삽입, 삭제, 변경)연산을 수행한다.

#### **질의 적중 비율**

$$
\frac{질의\,응답을\,위해\,접근해야\,되는\,레코드\,수}{화일\,전체의\,레코드\,수}
$$

화일의 질의 적중 비율이 높으면, 레코드 전체에 대한 접근이 잦기 때문에, 입력 순차 화일 구조가 적합하다.

# **키 순차 화일의 갱신**
삽입 삭제 수정의 연산 모두 해당 연산을 수행할 키값을 받고

해당 키를 기준으로 그 전의 레코드들은 모두 새로운 화일에 복사하며,

키가 일치하는 곳에 새로운 레코드를 삽입하거나, 삭제할 경우 해당 레코드를 건너뛰고, 수정할 경우 수정하여 나머지 레코드들과 함께 새로운 화일에 복사한다.

## **트랜잭션 화일**
갱신할 내용들을 트랜잭션 화일의 트랜잭션 레코드를 추가하며 기록한다.
* 마스터 화일과 같은 순서로 키를 정렬해야 된다.

#### 트랜잭션 코드
레코드 갱신에 대한 정보를 위해 I(삽입), D(삭제), C(수정) 3가지 중 하나를 명시해야된다.

### **트랜잭션의 삽입**
레코드 키 값이 필요하며, 기타 데이터 필드 값은 선택적으로 명시한다.
### **트랜잭션의 삭제**
삭제할 레코드의 키 값만을 명세한다.
### **트랜잭션의 수정**
수정될 필드와 관련된 값과 수정될 레코드의 키 값을 명세한다.

### **마스터 화일의 갱신 빈도**
갱신 빈도를 결정하는 요인은 다음과 같다.
1. 데이터 내용의 변경율
2. 마스터 화일의 크기
3. 마스터 화일에 대한 최신 데이터 요구
4. 화일 활동 비율

    $$
    \frac{일련의\,트랜젝션에\,의해\,영향을\,받는\,화일의\,레코드\,수}{화일의\,총\,레코드\,수}
    $$

## **마스터 화일의 갱신 알고리즘**
1. **masterKey < transKey**
    * 해당 마스터 레코드에 적용할 명령이 없다.

        -> 새로운 마스터 화일에 복사 후 다음 마스터 레코드 키를 불러온다.
2. **masterKey = transKey**
    * 수정인 경우 : 마스터 레코드 내의 필드 값을 변경한 이후, 새로운 마스터 화일에 삽입.
    * 삭제인 경우 : 마스터 레코드를 새로운 마스터 화일에 삽입하지 않고 건너뛴다.
    * 삽입인 경우 : 이미 마스터 파일에 해당 값을 가진 레코드가 있기 때문에 중복 레코드라는 오류 메시지를 출력한다.
3. **masterKey > transKey**
    * 트랜잭션 레코드 키와 일치하는 마스터 레코드가 없는 경우.
        * 삽입인 경우 : 레코드를 구성해서 새로운 마스터 화일에 삽입.
        * 수정이나 삭제인 경우 : 적절한 오류 메시지 출력

* 하나의 마스터 레코드에 여러 트랜잭션을 적용해야 되는 경우
    * 트랜잭션 레코드를 1차적으로 transKey로 정렬한 이후, 명령 발생 시간으로 정렬한다.